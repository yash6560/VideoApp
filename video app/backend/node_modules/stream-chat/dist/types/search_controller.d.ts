import type { DebouncedFunc } from './utils';
import { StateStore } from './store';
import type { Channel } from './channel';
import type { StreamChat } from './client';
import type { ChannelFilters, ChannelOptions, ChannelSort, MessageFilters, MessageResponse, SearchMessageSort, UserFilters, UserOptions, UserResponse, UserSort } from './types';
export type SearchSourceType = 'channels' | 'users' | 'messages' | (string & {});
export type QueryReturnValue<T> = {
    items: T[];
    next?: string | null;
};
export type DebounceOptions = {
    debounceMs: number;
};
type DebouncedExecQueryFunction = DebouncedFunc<(searchString?: string) => Promise<void>>;
export interface SearchSource<T = any> {
    activate(): void;
    cancelScheduledQuery(): void;
    canExecuteQuery(newSearchString?: string): boolean;
    deactivate(): void;
    readonly hasNext: boolean;
    readonly hasResults: boolean;
    readonly initialState: SearchSourceState<T>;
    readonly isActive: boolean;
    readonly isLoading: boolean;
    readonly items: T[] | undefined;
    readonly lastQueryError: Error | undefined;
    readonly next: string | undefined | null;
    readonly offset: number | undefined;
    resetState(): void;
    search(text?: string): Promise<void> | undefined;
    readonly searchQuery: string;
    setDebounceOptions(options: DebounceOptions): void;
    readonly state: StateStore<SearchSourceState<T>>;
    readonly type: SearchSourceType;
}
export type SearchSourceState<T = any> = {
    hasNext: boolean;
    isActive: boolean;
    isLoading: boolean;
    items: T[] | undefined;
    searchQuery: string;
    lastQueryError?: Error;
    next?: string | null;
    offset?: number;
};
export type SearchSourceOptions = {
    /** The number of milliseconds to debounce the search query. The default interval is 300ms. */
    debounceMs?: number;
    pageSize?: number;
};
export declare abstract class BaseSearchSource<T> implements SearchSource<T> {
    state: StateStore<SearchSourceState<T>>;
    protected pageSize: number;
    abstract readonly type: SearchSourceType;
    protected searchDebounced: DebouncedExecQueryFunction;
    protected constructor(options?: SearchSourceOptions);
    get lastQueryError(): Error | undefined;
    get hasNext(): boolean;
    get hasResults(): boolean;
    get isActive(): boolean;
    get isLoading(): boolean;
    get initialState(): {
        hasNext: boolean;
        isActive: boolean;
        isLoading: boolean;
        items: undefined;
        lastQueryError: undefined;
        next: undefined;
        offset: number;
        searchQuery: string;
    };
    get items(): T[] | undefined;
    get next(): string | null | undefined;
    get offset(): number | undefined;
    get searchQuery(): string;
    protected abstract query(searchQuery: string): Promise<QueryReturnValue<T>>;
    protected abstract filterQueryResults(items: T[]): T[] | Promise<T[]>;
    setDebounceOptions: ({ debounceMs }: DebounceOptions) => void;
    activate: () => void;
    deactivate: () => void;
    canExecuteQuery: (newSearchString?: string) => boolean;
    protected getStateBeforeFirstQuery(newSearchString: string): SearchSourceState<T>;
    protected getStateAfterQuery(stateUpdate: Partial<SearchSourceState<T>>, isFirstPage: boolean): SearchSourceState<T>;
    executeQuery(newSearchString?: string): Promise<void>;
    search: (searchQuery?: string) => Promise<void> | undefined;
    cancelScheduledQuery(): void;
    resetState(): void;
    resetStateAndActivate(): void;
}
export declare class UserSearchSource extends BaseSearchSource<UserResponse> {
    readonly type = "users";
    private client;
    filters: UserFilters | undefined;
    sort: UserSort | undefined;
    searchOptions: Omit<UserOptions, 'limit' | 'offset'> | undefined;
    constructor(client: StreamChat, options?: SearchSourceOptions);
    protected query(searchQuery: string): Promise<{
        items: UserResponse[];
    }>;
    protected filterQueryResults(items: UserResponse[]): UserResponse[];
}
export declare class ChannelSearchSource extends BaseSearchSource<Channel> {
    readonly type = "channels";
    private client;
    filters: ChannelFilters | undefined;
    sort: ChannelSort | undefined;
    searchOptions: Omit<ChannelOptions, 'limit' | 'offset'> | undefined;
    constructor(client: StreamChat, options?: SearchSourceOptions);
    protected query(searchQuery: string): Promise<{
        items: Channel[];
    }>;
    protected filterQueryResults(items: Channel[]): Channel[];
}
export declare class MessageSearchSource extends BaseSearchSource<MessageResponse> {
    readonly type = "messages";
    private client;
    messageSearchChannelFilters: ChannelFilters | undefined;
    messageSearchFilters: MessageFilters | undefined;
    messageSearchSort: SearchMessageSort | undefined;
    channelQueryFilters: ChannelFilters | undefined;
    channelQuerySort: ChannelSort | undefined;
    channelQueryOptions: Omit<ChannelOptions, 'limit' | 'offset'> | undefined;
    constructor(client: StreamChat, options?: SearchSourceOptions);
    protected query(searchQuery: string): Promise<{
        items: never[];
        next?: undefined;
    } | {
        items: MessageResponse[];
        next: string | undefined;
    }>;
    protected filterQueryResults(items: MessageResponse[]): MessageResponse[];
}
export type SearchControllerState = {
    isActive: boolean;
    searchQuery: string;
    sources: SearchSource[];
};
export type InternalSearchControllerState = {
    focusedMessage?: MessageResponse;
};
export type SearchControllerConfig = {
    keepSingleActiveSource: boolean;
};
export type SearchControllerOptions = {
    config?: Partial<SearchControllerConfig>;
    sources?: SearchSource[];
};
export declare class SearchController {
    /**
     * Not intended for direct use by integrators, might be removed without notice resulting in
     * broken integrations.
     */
    _internalState: StateStore<InternalSearchControllerState>;
    state: StateStore<SearchControllerState>;
    config: SearchControllerConfig;
    constructor({ config, sources }?: SearchControllerOptions);
    get hasNext(): boolean;
    get sources(): SearchSource<any>[];
    get activeSources(): SearchSource<any>[];
    get isActive(): boolean;
    get searchQuery(): string;
    get searchSourceTypes(): Array<SearchSource['type']>;
    addSource: (source: SearchSource) => void;
    getSource: (sourceType: SearchSource["type"]) => SearchSource<any> | undefined;
    removeSource: (sourceType: SearchSource["type"]) => void;
    activateSource: (sourceType: SearchSource["type"]) => void;
    deactivateSource: (sourceType: SearchSource["type"]) => void;
    activate: () => void;
    search: (searchQuery?: string) => Promise<void>;
    cancelSearchQueries: () => void;
    clear: () => void;
    exit: () => void;
}
export {};
